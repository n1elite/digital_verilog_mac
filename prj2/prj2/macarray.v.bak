/*****************************************
    
    Team XX : 
        2024000000    Kim Mina
        2024000001    Lee Minho
*****************************************/



////////////////////////////////////
//  TOP MODULE
////////////////////////////////////
module macarray (
    input     wire              CLK,
    input     wire              RSTN,
	input	  wire	  [11:0]	MNT,
	input	  wire				START,
	
    output    wire              EN_I,
    output    wire    [2:0]     ADDR_I,
    input     wire    [63:0]    RDATA_I,
	output    wire              EN_W,
    output    wire    [2:0]     ADDR_W,
    input     wire    [63:0]    RDATA_W,
	
    output    wire              EN_O,
    output    wire              RW_O,
    output    wire    [3:0]     ADDR_O,
    output    wire    [63:0]    WDATA_O,
    input     wire    [63:0]    RDATA_O
);

	parameter SIZE = 8;
	
	reg [7:0] input_matrix [7:0][7:0];
	reg [7:0] weight_matrix [7:0][7:0];
	reg [7:0] output_matrix [7:0][7:0];
	
	reg [3:0] m,n,t;
	integer i,j,k;
	
	parameter IDLE = 2'b00;
	parameter LOAD = 2'b01;
	parameter COMPUTE = 2b'10;
	parameter STORE = 2'b11;

	reg [1:0] current_state, next_state;

	always @(posedge CLK or negedge RSTN) begin
		if(!RSTN) begin
			m <= 0;
			n <= 0;
			t <= 0;
		end else if(START) begin
			m <= MNT[11:8];
			n <= MNT[7:4];
			t <= MNT[3:0];
		end
	end

	
    // WRITE YOUR CONTROL SYSTEM CODE
	always @(posedge CLK or negedge RSTN) begin
		if(!RSTN)
			current_state < = IDLE;
		else
			current_state <= next_state;
	end
	
	always @(*) begin
		case(current_state)
			IDLE : next_state = start ? LOAD : IDLE;
			LOAD : next_state = (t_count == (t-1) && m_count == (n-1)) ? COMPUTE : LOAD;
			COMPUTE : next_state = STORE;
			STORE : next_state = IDLE;
			default : next_state = IDLE;
		endcase
	end
	
	reg [3:0] m_count, n_count, t_count;
    // WRITE YOUR MAC_ARRAY DATAPATH CODE
	always @(posedge CLK or negedge RSTN) begin
		if(!RSTN)begin
			ADDR_I <= 0;
			ADDR_W <= 0;
			EN_I <= 0;
			EN_W <= 0;
			m_copunt <= 0;
			n_count <= 0;
			t_count <= 0;
		end else if(current_state == LOAD) begin
			EN_I <= 1;
			EN_W <= 1;
			input_matrix[t_count][n_count] = RDATA_I[63 - n_count*7, 56 - n_count*7];
			weight_matrix[n_count][m_count] = RDATA_W[63 - n_count*7, 56 - n_count*7];
			
			if (n_count < n - 1) begin
        			n_count <= n_count + 1;
    			end else begin
        			n_count <= 0;

        			// t_count ??
        			if (t_count < t - 1) begin
            				t_count <= t_count + 1;
            				ADDR_I <= ADDR_I + 1;
        			end else if (m_count == m-1)begin
            				t_count <= 0;
            				ADDR_I <= ADDR_I - (t-1);
        			end

        			// m_count ??
        			if (m_count < m - 1) begin
            				m_count <= m_count + 1;
            				ADDR_W <= ADDR_W + 1;
        			end else if (t_count == t-1)begin
            				m_count <= 0;
    				        ADDR_W <= ADDR_W - (m-1);
        			end
			end
		end else begin
			EN_I <= 0;
			EN_W <= 0;
		end
	end
	

	   // Compute Logic
    	always @(posedge CLK or negedge RSTN) begin
    		if (!RSTN) begin
        		for (i = 0; i < SIZE; i = i + 1) begin
            			for (j = 0; j < SIZE; j = j + 1) begin
                			output_matrix[i][j] <= 0;
            			end
        		end
    		end else if (current_state == COMPUTE) begin
        	// 4x4 MAC Array computation
        		for (i = 0; i < T; i = i + 4) begin
            			for (j = 0; j < M; j = j + 4) begin
                			for (k = 0; k < N; k = k + 4) begin
                    			// Feed 4x4 blocks to MAC Array
                    				for (x = 0; x < 4; x = x + 1) begin
              				                for (y = 0; y < 4; y = y + 1) begin
                            				// Partial accumulation
        				                    output_matrix[i+x][j+y] <= output_matrix[i+x][j+y] +
                                							(input_matrix[i+x][k+0] * weight_matrix[k+0][j+y]) +
                     								           (input_matrix[i+x][k+1] * weight_matrix[k+1][j+y]) +
                 								               (input_matrix[i+x][k+2] * weight_matrix[k+2][j+y]) +
                 									             (input_matrix[i+x][k+3] * weight_matrix[k+3][j+y]);
                        				end
                   				end
                			end
            			end
        		end
    		end
	end

	


endmodule
